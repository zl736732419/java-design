###说明
    各个设计模式的讲解详见具体包中README.md
###设计模式总结
1. 抽象工厂模式
    抽象工厂模式主要是应对一系列对象的改变，而对象内部的接口实现不会发生相应的变化，比如对象风格变化   由古典(门、窗、床)到现代(门、窗、床)
2. 工厂方法模式
	工厂方法模式主要应对一个对象发生在一个纬度原因上频繁改变，但是该对象内部的实现接口不会发生剧烈变化,其实相当于也是风格的变化
3. 生成器模式
    生成器模式主要应对的是一个复杂对象的创建过程，将一个复杂对象的创建，转化
    为内部其他对象的组合创建，内部对象的改变也是该内部对象系列的变化，但是他们与主对象存在整体和部分的关系
4. 原型模式
    需要创建许多相同的对象，但是这些对象内部的属性、方法等都不会发生变化，感
    觉这些对象就是该对象的拷贝
5. 适配器模式
    适配器模式主要是应对需要引用已经设计好的稳定的原有对象，但是该对象的内部
    实现接口与客户的实现接口不同，适配器需要实现目标接口，并持有一个原有对象的引用
6. 桥接模式
	一个对象存在不同纬度原因的变化，比如CCTV存在频道的不同，播放内容的方式也不同，而不同频道播放的内容也不相同，将其他的变化纬度封装成一个类
7. 组合模式
    使用户对单个对象和组合对象的使用具有一致性，通过树形结构表示主对象和子对象的结构关系，对于主对象内部的结构不暴露到客户程序中
8. 装饰模式
    对象内部接口没有发生变化，但是接口中的业务功能需要进行扩展，而不添加多于
    的对象，通过装饰者，既接口实现，又对象组合，解决主体类在多个方向上的功能拓展，装饰者实现或继承被装饰者，同时持有被装饰者的一个引用
9. 外观模式
    将一个复杂的业务划分为许多小的子业务，但是客户程序不会直接和子业务进行耦合，它通过一个外观类提供访问这些子业务的公共接口来间接和子业务进行访问
10. 享元模式
    降低对象内部的细粒度对象给系统带来的压力，细粒度对象存储在一个静态的Map中，其实就是一个缓存机理
11. 代理模式
    在面向对象系统中，有些对象由于某种原因，直接访问会导致系统或者软件会带来极大的麻烦，为了不失去操作透明性，通过代理来代替，代理对象和客户程序在同一地址空间，但业务对象可以分发到不同的地址空间，比如远程业务,代理对象组合和实现目的接口
12. 模版方法
    定义一个算法的骨架，而将一些步骤延迟到子类中去实现，该模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤
13. 命令模式
    将请求封装成一个对象，这里就是把行为或命令封装成为一个对象，原来的对象不
    能进行任何改变，客户程序与原来的对象之间关系通过添加一个命令抽象类联系起来
14. 中介模式
    多个对象相互关联交互的情况，对象之间常常维持一个复杂的引用关系，把这样的复杂关系用一个中介对象来管理,中介者使各个对象之间互相不需要显示的引用，相互独立，中介者中封装了各个对象交互的接口，外观模式是外部对象与内部对象之间的关系，中介者模式是内部多个对象之间的关联
15. 观察者模式
    对通知的依赖，当对象状态发生变化，所有与之相关的对象都可以得到通知；定义对象的一对多关系
16. 责任链模式
    某些对象的请求接受者可能多样化在每个处理器中提供一个下个处理器的接口，同时提供自己处理的业务接口
17. 备忘录模式
    对象状态变化无常，需要对对象的状态进行回溯，捕获对象内部状态，在对象之外保存该对象状态，但备忘录对象不提供操作该对象的操作方法
18. 访问者模式
    由于需求的改变，某些类层次结构中常常会需要添加新的方法，如果直接在基类中新增方法会给子类带来很繁重的麻烦，子类不得不继承实现该方法，在不改变原来对象类结构的情况下，添加对于这个类的新操作，以后要对类添加新方法就直接继承Visitor